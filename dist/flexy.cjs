"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});function P(n,o){const e=o.getAttribute("position"),t=new n.Box3;t.center=new n.Vector3;for(let r=0;r<e.count;r++){const a=new n.Vector3;a.fromBufferAttribute(e,r),t.expandByPoint(a);const u=e[r],y=e[r+1],s=e[r+2];t.center.add(new n.Vector3(u,y,s))}return t.center.divideScalar(e.count/3),t}const C=function({THREE:n,curve:o,quaternion:e,orientation:t,bufferGeometry:r,axis:a,scene:u}){const y=P(n,r),s=r.attributes.position.array;for(let l=0;l<s.length;l+=3){const i=parseFloat(s[l]),m=parseFloat(s[l+1]),c=parseFloat(s[l+2]);if(a==="x"){const x=(i-y.min.x)/(y.max.x-y.min.x),w=o.getPointAt(x),g=o.getTangent(x),p=(t||new n.Vector3(0,0,1).applyQuaternion(e).normalize().multiplyScalar(1e6)).clone().cross(g.clone()).normalize(),h=new n.Quaternion().setFromAxisAngle(g.clone(),Math.atan2(c,m));p.applyQuaternion(h);const z=p.clone().setLength(new n.Vector3(0,m,c).length()),d=w.clone().add(z);s[l]=d.x,s[l+1]=d.y,s[l+2]=d.z}else if(a==="z"){const x=(c-y.min.z)/(y.max.z-y.min.z),w=o.getPointAt(x),g=o.getTangent(x),p=(t||new n.Vector3(1,0,0).applyQuaternion(e).normalize().multiplyScalar(1e6)).clone().cross(g.clone()).normalize(),h=new n.Quaternion().setFromAxisAngle(g.clone(),Math.atan2(m,i)+Math.PI/2);p.applyQuaternion(h);const z=p.clone().setLength(new n.Vector3(i,m,0).length()),d=w.clone().add(z);s[l]=d.x,s[l+1]=d.y,s[l+2]=d.z}else if(a==="y"){const x=(m-y.min.y)/(y.max.y-y.min.y),w=o.getPointAt(x),g=o.getTangent(x),p=(t.normalize().multiplyScalar(1e6)||new n.Vector3(0,1,0).applyQuaternion(e).normalize().multiplyScalar(1e6)).clone().cross(g.clone()).normalize(),h=new n.Quaternion().setFromAxisAngle(g.clone(),Math.atan2(i,c));p.applyQuaternion(h);const z=p.clone().setLength(new n.Vector3(i,0,c).length()),d=w.clone().add(z);s[l]=d.x,s[l+1]=d.y,s[l+2]=d.z}}r.attributes.position.needsUpdate=!0},N=function({THREE:n,reflectionMap:o,obj:e,scene:t}){const r=new n.Vector3(o.collisionPlane.A.x,o.collisionPlane.A.y,o.collisionPlane.A.z),a=new n.Vector3(o.collisionPlane.B.x,o.collisionPlane.B.y,o.collisionPlane.B.z),u=new n.Vector3(o.collisionPlane.C.x,o.collisionPlane.C.y,o.collisionPlane.C.z),y=new n.Vector3().subVectors(a,r),s=new n.Vector3().subVectors(u,r),l=new n.Vector3().crossVectors(y,s).normalize(),i=new n.Plane;i.setFromNormalAndCoplanarPoint(l,r);const m=e.geometry.attributes.position.array;for(let c=0;c<m.length;c+=3){const x=parseFloat(m[c]),w=parseFloat(m[c+1]),g=parseFloat(m[c+2]),f=new n.Vector3(x,w,g);f.applyMatrix4(e.matrixWorld);const p=f.clone().sub(r).dot(i.normal),h=i.normal.clone().multiplyScalar(p/i.normal.lengthSq()),z=f.clone().sub(h),d=b(z.x,z.y,z.z,o.resolution),A=o.data[d];if(!A){console.error("asdads");continue}const Q=new n.Vector3(A.normal.x,A.normal.y,A.normal.z),F=new n.Object3D;F.lookAt(Q);const V=new n.Vector3(x,w,g).clone().applyQuaternion(F.quaternion);m[c]=V.x,m[c+1]=V.y,m[c+2]=V.z}e.geometry.attributes.position.needsUpdate=!0},S=function({THREE:n,surface:o,resolution:e,collisionPlane:t,scene:r}){const a={};for(let u=0;u<=e;u++){const y=B(n,t.A,t.D,e)[u],s=B(n,t.B,t.C,e)[u];B(n,y,s,e).forEach(i=>{const c=new n.Raycaster(i,t.direction.normalize()).intersectObject(o);c.length>0&&(a[b(i.x,i.y,i.z,e)]={normal:{x:c[0].face.normal.x,y:c[0].face.normal.y,z:c[0].face.normal.z},point:{x:c[0].point.x,y:c[0].point.y,z:c[0].point.z}})})}return{data:a,collisionPlane:{A:{x:t.A.x,y:t.A.y,z:t.A.z},B:{x:t.B.x,y:t.B.y,z:t.B.z},C:{x:t.C.x,y:t.C.y,z:t.C.z},D:{x:t.D.x,y:t.D.y,z:t.D.z},direction:{x:t.direction.x,y:t.direction.y,z:t.direction.z}},resolution:e}};function b(n,o,e,t){function r(i,m){return Math.round(i/m)*m}function a(i){return i==="-0.0"?"0.0":i}const u=1/t,y=a(r(n,u).toFixed(1)),s=a(r(o,u).toFixed(1)),l=a(r(e,u).toFixed(1));return`${y}^${s}^${l}`}function B(n,o,e,t){const r=[];for(let a=0;a<=t;a++){const u=new n.Vector3(o.x+(e.x-o.x)*(a/t),o.y+(e.y-o.y)*(a/t),o.z+(e.z-o.z)*(a/t));r.push(u)}return r}exports.bend=C;exports.getReflectionMap=S;exports.wrap=N;

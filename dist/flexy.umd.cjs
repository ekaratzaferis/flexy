(function(w,B){typeof exports=="object"&&typeof module<"u"?B(exports):typeof define=="function"&&define.amd?define(["exports"],B):(w=typeof globalThis<"u"?globalThis:w||self,B(w.flexy={}))})(this,function(w){"use strict";function B(n,c){const o=c.getAttribute("position"),e=new n.Box3;e.center=new n.Vector3;for(let t=0;t<o.count;t++){const r=new n.Vector3;r.fromBufferAttribute(o,t),e.expandByPoint(r);const s=o[t],a=o[t+1],i=o[t+2];e.center.add(new n.Vector3(s,a,i))}return e.center.divideScalar(o.count/3),e}const S=function({THREE:n,curve:c,quaternion:o,orientation:e,bufferGeometry:t,axis:r,scene:s}){const a=B(n,t),i=t.attributes.position.array;for(let y=0;y<i.length;y+=3){const m=parseFloat(i[y]),p=parseFloat(i[y+1]),l=parseFloat(i[y+2]);if(r==="x"){const f=(m-a.min.x)/(a.max.x-a.min.x),u=c.getPointAt(f),x=c.getTangent(f),z=(e||new n.Vector3(0,0,1).applyQuaternion(o).normalize().multiplyScalar(1e6)).clone().cross(x.clone()).normalize(),h=new n.Quaternion().setFromAxisAngle(x.clone(),Math.atan2(l,p));z.applyQuaternion(h);const A=z.clone().setLength(new n.Vector3(0,p,l).length()),d=u.clone().add(A);i[y]=d.x,i[y+1]=d.y,i[y+2]=d.z}else if(r==="z"){const f=(l-a.min.z)/(a.max.z-a.min.z),u=c.getPointAt(f),x=c.getTangent(f),z=(e||new n.Vector3(1,0,0).applyQuaternion(o).normalize().multiplyScalar(1e6)).clone().cross(x.clone()).normalize(),h=new n.Quaternion().setFromAxisAngle(x.clone(),Math.atan2(p,m)+Math.PI/2);z.applyQuaternion(h);const A=z.clone().setLength(new n.Vector3(m,p,0).length()),d=u.clone().add(A);i[y]=d.x,i[y+1]=d.y,i[y+2]=d.z}else if(r==="y"){const f=(p-a.min.y)/(a.max.y-a.min.y),u=c.getPointAt(f),x=c.getTangent(f),z=(e.normalize().multiplyScalar(1e6)||new n.Vector3(0,1,0).applyQuaternion(o).normalize().multiplyScalar(1e6)).clone().cross(x.clone()).normalize(),h=new n.Quaternion().setFromAxisAngle(x.clone(),Math.atan2(m,l));z.applyQuaternion(h);const A=z.clone().setLength(new n.Vector3(m,0,l).length()),d=u.clone().add(A);i[y]=d.x,i[y+1]=d.y,i[y+2]=d.z}}t.attributes.position.needsUpdate=!0},D=function({THREE:n,surface:c,castingRectangular:o,resolution:e,scene:t}){const r={};b(n,t,o.A,o.B,"#f0f"),b(n,t,o.B,o.C,"#f0f"),b(n,t,o.C,o.D,"#f0f"),b(n,t,o.D,o.A,"#f0f");for(let s=0;s<=e;s++){const a=P(n,o.A,o.D,e)[s],i=P(n,o.B,o.C,e)[s];P(n,a,i,e).forEach(m=>{const l=new n.Raycaster(m,o.direction.normalize()).intersectObject(c);l.length>0&&(r[Q(m.x,m.y,m.z,e)]={normal:{x:l[0].face.normal.x,y:l[0].face.normal.y,z:l[0].face.normal.z},point:{x:l[0].point.x,y:l[0].point.y,z:l[0].point.z}})})}return{data:r,castingRectangular:{A:{x:o.A.x,y:o.A.y,z:o.A.z},B:{x:o.B.x,y:o.B.y,z:o.B.z},C:{x:o.C.x,y:o.C.y,z:o.C.z},D:{x:o.D.x,y:o.D.y,z:o.D.z},direction:{x:o.direction.x,y:o.direction.y,z:o.direction.z}},resolution:e}},M=function({THREE:n,pointToFaceNormalMap:c,obj:o,scene:e}){const t=c.castingRectangular,r=new n.Vector3(t.A.x,t.A.y,t.A.z),s=new n.Vector3(t.B.x,t.B.y,t.B.z),a=new n.Vector3(t.C.x,t.C.y,t.C.z),i=new n.Vector3().subVectors(s,r),y=new n.Vector3().subVectors(a,r),m=new n.Vector3().crossVectors(i,y).normalize(),p=new n.Plane().setFromNormalAndCoplanarPoint(m,r),l=o.geometry.attributes.position.array;for(let f=0;f<l.length;f+=3){const u=parseFloat(l[f]),x=parseFloat(l[f+1]),V=parseFloat(l[f+2]),z=new n.Vector3(u,x,V);z.applyMatrix4(o.matrixWorld);const h=z.clone().sub(r).dot(p.normal),A=p.normal.clone().multiplyScalar(h/p.normal.lengthSq()),d=z.clone().sub(A),L=Q(d.x,d.y,d.z,c.resolution),F=c.data[L];if(!F)throw new Error(`Cannot find face normal for posision ${u} - ${x} - ${V}`);const $=new n.Vector3(F.normal.x,F.normal.y,F.normal.z),N=new n.Object3D;N.lookAt($);const C=new n.Vector3(u,x,V).applyQuaternion(N.quaternion);l[f]=C.x,l[f+1]=C.y,l[f+2]=C.z}o.geometry.attributes.position.needsUpdate=!0};function Q(n,c,o,e){function t(m,p){return Math.round(m/p)*p}function r(m){return m==="-0.0"?"0.0":m}const s=1/e,a=r(t(n,s).toFixed(1)),i=r(t(c,s).toFixed(1)),y=r(t(o,s).toFixed(1));return`${a}^${i}^${y}`}function P(n,c,o,e){const t=[];for(let r=0;r<=e;r++){const s=new n.Vector3(c.x+(o.x-c.x)*(r/e),c.y+(o.y-c.y)*(r/e),c.z+(o.z-c.z)*(r/e));t.push(s)}return t}function b(n,c,o={x:0,y:0,z:0},e,t){const r=new n.BufferGeometry,s=new Float32Array(2*3);s[0]=o.x,s[1]=o.y,s[2]=o.z,s[3]=e.x,s[4]=e.y,s[5]=e.z,r.setAttribute("position",new n.BufferAttribute(s,3));const a=new n.LineBasicMaterial({color:t}),i=new n.Line(r,a);return c.add(i),i}w.bend=S,w.getPointToFaceNormalMap=D,w.wrap=M,Object.defineProperty(w,Symbol.toStringTag,{value:"Module"})});

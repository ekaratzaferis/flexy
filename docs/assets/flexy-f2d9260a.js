function B(t,l){const c=l.getAttribute("position"),i=new t.Box3;i.center=new t.Vector3;for(let e=0;e<c.count;e++){const g=new t.Vector3;g.fromBufferAttribute(c,e),i.expandByPoint(g);const x=c[e],L=c[e+1],n=c[e+2];i.center.add(new t.Vector3(x,L,n))}return i.center.divideScalar(c.count/3),i}const b=function({THREE:t,curve:l,quaternion:c,orientation:i,bufferGeometry:e,axis:g,preserveDimensions:x=!1,scene:L}){const n=B(t,e),d=x?C(l):0,r=e.attributes.position.array;for(let o=0;o<r.length;o+=3){const f=parseFloat(r[o]),P=parseFloat(r[o+1]),z=parseFloat(r[o+2]);if(g==="x"){let a=(f-n.min.x)/(n.max.x-n.min.x);const m=n.max.x-n.min.x;if(x&&m<=d){const h=m/d,y=.5-h/2,F=.5+h/2;a=y+a*(F-y)}const A=l.getPointAt(a),p=l.getTangent(a),u=(i||new t.Vector3(0,0,1).applyQuaternion(c).normalize().multiplyScalar(1e6)).clone().cross(p.clone()).normalize(),w=new t.Quaternion().setFromAxisAngle(p.clone(),Math.atan2(z,P));u.applyQuaternion(w);const Q=u.clone().setLength(new t.Vector3(0,P,z).length()),s=A.clone().add(Q);r[o]=s.x,r[o+1]=s.y,r[o+2]=s.z}else if(g==="z"){let a=(z-n.min.z)/(n.max.z-n.min.z);const m=n.max.z-n.min.z;if(x&&m<=d){const h=m/d,y=.5-h/2,F=.5+h/2;a=y+a*(F-y)}const A=l.getPointAt(a),p=l.getTangent(a),u=(i||new t.Vector3(1,0,0).applyQuaternion(c).normalize().multiplyScalar(1e6)).clone().cross(p.clone()).normalize(),w=new t.Quaternion().setFromAxisAngle(p.clone(),Math.atan2(P,f)+Math.PI/2);u.applyQuaternion(w);const Q=u.clone().setLength(new t.Vector3(f,P,0).length()),s=A.clone().add(Q);r[o]=s.x,r[o+1]=s.y,r[o+2]=s.z}else if(g==="y"){let a=(P-n.min.y)/(n.max.y-n.min.y);const m=n.max.y-n.min.y;if(x&&m<=d){const h=m/d,y=.5-h/2,F=.5+h/2;a=y+a*(F-y)}const A=l.getPointAt(a),p=l.getTangent(a),u=(i||new t.Vector3(1,0,0).applyQuaternion(c).normalize().multiplyScalar(1e6)).clone().cross(p.clone()).normalize(),w=new t.Quaternion().setFromAxisAngle(p.clone(),Math.atan2(f,z));u.applyQuaternion(w);const Q=u.clone().setLength(new t.Vector3(f,0,z).length()),s=A.clone().add(Q);r[o]=s.x,r[o+1]=s.y,r[o+2]=s.z}}e.attributes.position.needsUpdate=!0};function C(t){let c=0,i=t.getPointAt(0);for(let e=1;e<=100;e++){const g=t.getPointAt(e/100);c+=g.distanceTo(i),i=g}return c}export{b};

function b(t,i){const c=i.getAttribute("position"),g=new t.Box3;g.center=new t.Vector3;for(let n=0;n<c.count;n++){const a=new t.Vector3;a.fromBufferAttribute(c,n),g.expandByPoint(a);const d=c[n],C=c[n+1],o=c[n+2];g.center.add(new t.Vector3(d,C,o))}return g.center.divideScalar(c.count/3),g}const N=function({THREE:t,curve:i,quaternion:c,orientation:g,bufferGeometry:n,axis:a,preserveDimensions:d=!1,scene:C}){const o=b(t,n),x=d?L(i):0,r=n.attributes.position.array;for(let e=0;e<r.length;e+=3){const m=parseFloat(r[e]),u=parseFloat(r[e+1]),P=parseFloat(r[e+2]);if(a==="x"){let s=(m-o.min.x)/(o.max.x-o.min.x);const p=o.max.x-o.min.x;if(d&&p<=x){const w=p/x,y=.5-w/2,V=.5+w/2;s=y+s*(V-y)}const z=i.getPointAt(s),h=i.getTangent(s),f=(g||new t.Vector3(0,0,1).applyQuaternion(c).normalize().multiplyScalar(1e6)).clone().cross(h.clone()).normalize(),A=new t.Quaternion().setFromAxisAngle(h.clone(),Math.atan2(P,u));f.applyQuaternion(A);const F=f.clone().setLength(new t.Vector3(0,u,P).length()),l=z.clone().add(F);r[e]=l.x,r[e+1]=l.y,r[e+2]=l.z}else if(a==="z"){let s=(P-o.min.z)/(o.max.z-o.min.z);const p=o.max.y-o.min.y;if(d&&p<=x){const w=p/x,y=.5-w/2,V=.5+w/2;s=y+s*(V-y)}const z=i.getPointAt(s),h=i.getTangent(s),f=(g||new t.Vector3(1,0,0).applyQuaternion(c).normalize().multiplyScalar(1e6)).clone().cross(h.clone()).normalize(),A=new t.Quaternion().setFromAxisAngle(h.clone(),Math.atan2(u,m)+Math.PI/2);f.applyQuaternion(A);const F=f.clone().setLength(new t.Vector3(m,u,0).length()),l=z.clone().add(F);r[e]=l.x,r[e+1]=l.y,r[e+2]=l.z}else if(a==="y"){let s=(u-o.min.y)/(o.max.y-o.min.y);const p=o.max.z-o.min.z;if(d&&p<=x){const w=p/x,y=.5-w/2,V=.5+w/2;s=y+s*(V-y)}const z=i.getPointAt(s),h=i.getTangent(s),f=(g||new t.Vector3(1,0,0).applyQuaternion(c).normalize().multiplyScalar(1e6)).clone().cross(h.clone()).normalize(),A=new t.Quaternion().setFromAxisAngle(h.clone(),Math.atan2(m,P));f.applyQuaternion(A);const F=f.clone().setLength(new t.Vector3(m,0,P).length()),l=z.clone().add(F);r[e]=l.x,r[e+1]=l.y,r[e+2]=l.z}}n.attributes.position.needsUpdate=!0},O=function({THREE:t,pointToFaceNormalMap:i,obj:c,scene:g}){const n=i.castingRectangular,a=new t.Vector3(n.A.x,n.A.y,n.A.z),d=new t.Vector3(n.B.x,n.B.y,n.B.z),C=new t.Vector3(n.C.x,n.C.y,n.C.z),o=new t.Vector3().subVectors(d,a),x=new t.Vector3().subVectors(C,a),r=new t.Vector3().crossVectors(o,x).normalize(),e=new t.Plane().setFromNormalAndCoplanarPoint(r,a),m=c.geometry.attributes.position.array;for(let u=0;u<m.length;u+=3){const P=parseFloat(m[u]),s=parseFloat(m[u+1]),p=parseFloat(m[u+2]),z=new t.Vector3(P,s,p),h=c.matrixWorld.clone();z.applyMatrix4(h.clone());const Q=z.clone().sub(a).dot(e.normal),f=e.normal.clone().multiplyScalar(Q/e.normal.lengthSq()),A=z.clone().sub(f),F=B(A.x,A.y,A.z,i.resolution),l=i.data[F];if(!l)throw new Error(`Cannot find face normal for posision ${P} - ${s} - ${p}`);const w=new t.Vector3(l.normal.x,l.normal.y,l.normal.z),y=new t.Object3D;y.lookAt(w);const V=new t.Vector3(P,s,p).applyQuaternion(y.quaternion.clone());m[u]=V.x,m[u+1]=V.y,m[u+2]=V.z}c.geometry.attributes.position.needsUpdate=!0};function B(t,i,c,g){function n(r,e){return Math.round(r/e)*e}function a(r){return r==="-0.0"?"0.0":r}const d=1/g,C=a(n(t,d).toFixed(1)),o=a(n(i,d).toFixed(1)),x=a(n(c,d).toFixed(1));return`${C}^${o}^${x}`}function L(t){let c=0,g=t.getPointAt(0);for(let n=1;n<=100;n++){const a=t.getPointAt(n/100);c+=a.distanceTo(g),g=a}return c}export{N as b,O as w};
